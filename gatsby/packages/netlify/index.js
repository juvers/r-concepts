// @ts-check

/** @typedef {'lint' | 'typecheck'} Command */
/** @typedef {typeof PENDING | typeof SUCCESS | typeof FAILURE | typeof ERROR} Status */
/** @typedef {string | Error | (Error & {stdout: string, stderr: string})} ErrorLike */

/**
 * @typedef {object} PluginConstants Build Constants defined by Netlify
 * @prop {string} CONFIG_PATH Path to the Netlify configuration file.
 *                `undefined` if none was used
 * @prop {string} PUBLISH_DIR Directory that contains the deploy-ready
 *                HTML files and assets generated by the build.
 *                Its value is always defined, but the target
 *                might not have been created yet.
 * @prop {string} FUNCTIONS_SRC The directory where function source code lives.
 *                `undefined` if not specified by the user.
 * @prop {string} FUNCTIONS_DIST The directory where built serverless functions
 *                are placed before deployment.
 *                Its value is always defined, but the target
 *                might not have been created yet.
 * @prop {string} IS_LOCAL Boolean indicating whether the build was run locally
 *                (Netlify CLI) or in the production CI
 * @prop {string} NETLIFY_BUILD_VERSION Version of Netlify Build
 *                as a `major.minor.patch` string
 * @prop {string} SITE_ID The Netlify Site ID
 */

/**
 * @typedef {object} BuildUtils Utility to report errors.
 * @prop {(message?: string, options?: {error?: ErrorLike}) => void} failPlugin
 * @prop {(message?: string, options?: {error?: ErrorLike}) => void} failBuild
 * @prop {(message?: string, options?: {error?: ErrorLike}) => void} cancelBuild
 */

/**
 * @typedef {object} GitFileMatch An object representing git statuses for files matching a glob pattern.
 * @prop {string[]} modified All modified files matching a glob pattern.
 * @prop {string[]} created All created files matching a glob pattern.
 * @prop {string[]} deleted All deleted files matching a glob pattern.
 * @prop {string[]} edited All modified, created, or deleted files matching a glob pattern.
 */

/**
 * @typedef {object} GitUtils Utility for dealing with modified, created, deleted files since a git commit.
 * @prop {(pattern: string) => GitFileMatch} fileMatch A glob matcher function to detect the git status of a pattern of files.
 * @prop {string[]} modifiedFiles List of all modified files
 * @prop {string[]} createdFiles List of all created files
 * @prop {string[]} deletedFiles List of all deleted files
 * @prop {string[]} commits List of commits with details
 * @prop {() => Promise<number>} linesOfCode How many lines of code have changed
 */

/**
 * @typedef {object} StatusUtils Utility to display inform in the deploy summary.
 * @prop {(config: {summary: string}) => void} show
 */

/**
 * @typedef {object} RunUtils Utility for running commands.
 * @prop {(cmd: string, options?: object) => Promise<object>} command
 */

/**
 * @typedef {object} PluginUtils
 * @prop {BuildUtils} build Utility to report errors.
 *                    See https://github.com/netlify/build#error-reporting
 * @prop {StatusUtils} status Utility to display inform in the deploy summary.
 *                     See https://github.com/netlify/build#logging
 * @prop {RunUtils} run Utility for running commands.
 *                  See https://github.com/netlify/build/blob/master/packages/run-utils/README.md
 * @prop {GitUtils} git Utility for dealing with modified, created, deleted files since a git commit.
 *                  See https://github.com/netlify/build/blob/master/packages/git-utils/README.md
 */

/**
 * @typedef {object} PluginOptions Options passed to Netlify build plugin functions.
 * @prop {PluginConstants} constants Build Constants
 * @prop {PluginUtils} utils Core utilities
 * @prop {Error} [error] `onError` receives the error instance as argument
 */

const debug = require('debug')('tishman:netlify-plugin');
const invariant = require('invariant');
const {Octokit} = require('@octokit/rest');
const path = require('path');
const stripAnsi = require('strip-ansi');

const FAILURE = 'failure';
const PENDING = 'pending';
const SUCCESS = 'success';
const ERROR = 'error';

const {
  REPOSITORY_URL = 'https://github.com/hzdg/tishman',
  DEPLOY_ID = '',
  DEPLOY_URL = '',
  COMMIT_REF = '',
  GITHUB_TOKEN,
} = process.env;

invariant(GITHUB_TOKEN, 'GITHUB_TOKEN Environment variable is required');

const [OWNER, REPO] = REPOSITORY_URL.replace('https://github.com/', '').split(
  '/',
);

const WORKSPACE_DIR_RE = /^.*packages\/([^/]+).*$/;

const octokit = new Octokit({
  auth: GITHUB_TOKEN,
  userAgent: `@tishman/netlify-plugin - ${DEPLOY_ID} - `,
});

function getBuildLogURL() {
  if (DEPLOY_URL) {
    let siteName = DEPLOY_URL.split('--')[1];
    siteName = siteName.replace('.netlify.app', '');
    return `https://app.netlify.com/sites/${siteName}/deploys/${DEPLOY_ID}`;
  } else {
    return `https://app.netlify.com/`;
  }
}

/**
 * Get the name of the app being built on Netlify.
 *
 * @param {string} publishDir - The Netlify PUBLISH_DIR value.
 */
function getWorkspaceName(publishDir) {
  const workspaceDir = publishDir.replace(WORKSPACE_DIR_RE, '$1');
  invariant(workspaceDir, `Could not extract an app name from ${publishDir}`);
  const pkg = require(path.resolve(
    path.resolve(__dirname, '..'),
    `${workspaceDir}/package.json`,
  ));

  return pkg.name;
}

/**
 * @param {string} workspace
 * @param {Command} command
 */
function getContext(workspace, command) {
  return `yarn workspace ${workspace} run ${command}`;
}

/**
 * @param {string} workspace
 * @param {Command} command
 */
function getCommandString(workspace, command) {
  return `yarn workspace -s ${workspace} run -s ${command}`;
}

/** @param {ErrorLike} [error] */
function extractErrorDescription(error) {
  if (!error) return '';
  if (typeof error === 'string') return error;
  if ('stdout' in error) {
    return [
      stripAnsi(error.stdout).trim().split('\n').pop(),
      stripAnsi(error.stderr).trim().split('\n').pop(),
    ].join(' ');
  }
  if ('message' in error) return error.message;
  return String(error);
}

/**
 * @param {string} context
 * @param {Status} status
 * @param {string} [description]
 */
async function report(context, status, description) {
  debug(`Report: ${context} [${status}]`);
  debug(`Link: ${getBuildLogURL()}`);
  debug(description);
  try {
    const resp = await octokit.repos.createCommitStatus({
      owner: OWNER,
      repo: REPO,
      sha: COMMIT_REF,
      state: status,
      target_url: getBuildLogURL(),
      description,
      context,
    });
    debug(
      `${resp.data.context} (${resp.data.updated_at}) http status: ${resp.status}`,
    );
    debug(
      `${resp.data.context} (${resp.data.updated_at}) state: ${resp.data.state}`,
    );
    debug(
      `${resp.data.context} (${resp.data.updated_at}) description: "${resp.data.description}"`,
    );
  } catch (e) {
    /* We don't need to fail if reporting fails, but we should log it. */
    if (e.status && e.request) {
      console.error(`[${e.status}]: ${e.message}:`);
      console.error(e.request);
    } else {
      console.error(e);
    }
  }
}

/**
 * @param {string} workspace
 * @param {Command} command
 * @param {string} [message]
 */
function reportSuccess(workspace, command, message) {
  return () => report(getContext(workspace, command), SUCCESS, message);
}

/**
 * @param {string} workspace
 * @param {Command} command
 */
function reportCancelled(workspace, command) {
  return reportSuccess(workspace, command, 'Build Skipped!');
}

/**
 * @param {string} workspace
 * @param {Command} command
 */
function reportPending(workspace, command) {
  return () => report(getContext(workspace, command), PENDING);
}

/**
 * @param {string} workspace
 * @param {Command} command
 * @param {boolean} [shouldThrow]
 */
function reportFailure(workspace, command, shouldThrow) {
  return (
    /** @param {ErrorLike} error */
    async (error) => {
      const description = extractErrorDescription(error);
      await report(getContext(workspace, command), FAILURE, description);
      if (shouldThrow) throw error;
    }
  );
}

/**
 * @param {string} workspace
 * @param {Command} command
 * @param {boolean} [shouldThrow]
 */
function reportError(workspace, command, shouldThrow) {
  return (
    /** @param {ErrorLike} [error] */
    async (error) => {
      const description = extractErrorDescription(error);
      await report(getContext(workspace, command), ERROR, description);
      if (shouldThrow) throw error;
    }
  );
}

/**
 * @param {string} workspace
 * @param {GitUtils} git
 * @returns {Promise<false | string[]>}
 */
async function shouldBuild(workspace, git) {
  // TODO: Compute whether or not the workspace needs to be built.
  // The original alogrithm did the following:
  //   - forced build if `yarn.lock` changed
  //   - forced build if `crm/**` changed
  //     and `GATSBY_FORM_SUBMISSION_ENDPOINT` was defined
  //   - forced build if any files in the workspace changed
  //   - forced build if any files in dependencies of workspace changed,
  //     where 'dependencies' are other workspaces.
  const modified = Array.from(
    new Set([...git.modifiedFiles, ...git.createdFiles, ...git.deletedFiles]),
  );
  return modified.length ? modified : false;
}

/** @type {false | string[]} */
let failed = false;
/** @type {false | string[]} */
let buildReasons = false;
/** @type {string | undefined} */
let workspace;

module.exports = {
  /** @param {PluginOptions} options */
  async onPreBuild({constants: {PUBLISH_DIR}, utils: {build, git}}) {
    try {
      debug(`Getting workspace name for publish dir ${PUBLISH_DIR}`);
      workspace = getWorkspaceName(PUBLISH_DIR);
      debug(`Using workspace name ${workspace}`);
    } catch (e) {
      console.error(e);
      failed = [e];
    }
    if (workspace && !failed) {
      debug(`Checking for changes to ${workspace}`);
      try {
        buildReasons = await shouldBuild(workspace, git);
      } catch (e) {
        failed = [e];
      }

      if (!failed) {
        if (!buildReasons) {
          console.log('Skipping Build!');
          await Promise.allSettled([
            reportCancelled(workspace, 'lint')(),
            reportCancelled(workspace, 'typecheck')(),
          ]);
        } else {
          console.log('Building!');
          console.log('Changed:');
          buildReasons.forEach((reason) => console.log(`  ${reason}`));
          await Promise.allSettled([
            reportPending(workspace, 'lint')(),
            reportPending(workspace, 'typecheck')(),
          ]);
        }
      }
    }

    if (failed) {
      if (workspace) {
        await Promise.allSettled([
          reportError(workspace, 'lint')(failed[0]),
          reportError(workspace, 'typecheck')(failed[0]),
        ]);
      }
      // Fail the plugin if setting the prebuild status failed.
      build.failPlugin(failed.join('\n'));
    }
  },

  /** @param {PluginOptions} options */
  async onSuccess({utils: {build, status, run}}) {
    if (workspace && !failed) {
      await Promise.allSettled([
        run
          .command(getCommandString(workspace, 'lint'))
          .then(
            reportSuccess(workspace, 'lint'),
            reportFailure(workspace, 'lint', true),
          )
          .catch((e) => {
            (failed ? failed : (failed = [])).push(
              `lint: ${extractErrorDescription(e)}`,
            );
          }),
        run
          .command(getCommandString(workspace, 'typecheck'))
          .then(
            reportSuccess(workspace, 'typecheck'),
            reportFailure(workspace, 'typecheck', true),
          )
          .catch((e) => {
            (failed ? failed : (failed = [])).push(
              `typecheck: ${extractErrorDescription(e)}`,
            );
          }),
      ]);
    }

    if (failed) {
      // Fail the plugin if the lint or typecheck failed.
      build.failPlugin(failed.join('\n'));
    } else {
      // Display success information.
      status.show({summary: 'Success!'});
    }
  },

  /** @param {PluginOptions} options */
  async onError({error}) {
    if (workspace) {
      await Promise.allSettled([
        reportError(workspace, 'lint')(error),
        reportError(workspace, 'typecheck')(error),
      ]);
    }
  },
};
